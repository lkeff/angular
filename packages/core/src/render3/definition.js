"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GENERATED_COMP_IDS = void 0;
exports.ɵɵdefineComponent = ɵɵdefineComponent;
exports.extractDirectiveDef = extractDirectiveDef;
exports.ɵɵdefineNgModule = ɵɵdefineNgModule;
exports.ɵɵdefineDirective = ɵɵdefineDirective;
exports.ɵɵdefinePipe = ɵɵdefinePipe;
exports.extractDefListOrFactory = extractDefListOrFactory;
const constants_1 = require("../change_detection/constants");
const errors_1 = require("../errors");
const view_1 = require("../metadata/view");
const assert_1 = require("../util/assert");
const closure_1 = require("../util/closure");
const empty_1 = require("../util/empty");
const ng_dev_mode_1 = require("../util/ng_dev_mode");
const performance_1 = require("../util/performance");
const def_getters_1 = require("./def_getters");
const input_flags_1 = require("./interfaces/input_flags");
const node_selector_matcher_1 = require("./node_selector_matcher");
const standalone_service_1 = require("./standalone_service");
/**
 * Create a component definition object.
 *
 *
 * # Example
 * ```ts
 * class MyComponent {
 *   // Generated by Angular Template Compiler
 *   // [Symbol] syntax will not be supported by TypeScript until v2.7
 *   static ɵcmp = defineComponent({
 *     ...
 *   });
 * }
 * ```
 * @codeGenApi
 */
function ɵɵdefineComponent(componentDefinition) {
    return (0, closure_1.noSideEffects)(() => {
        var _a;
        // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.
        // See the `initNgDevMode` docstring for more information.
        (typeof ngDevMode === 'undefined' || ngDevMode) && (0, ng_dev_mode_1.initNgDevMode)();
        const baseDef = getNgDirectiveDef(componentDefinition);
        const def = Object.assign(Object.assign({}, baseDef), { decls: componentDefinition.decls, vars: componentDefinition.vars, template: componentDefinition.template, consts: componentDefinition.consts || null, ngContentSelectors: componentDefinition.ngContentSelectors, onPush: componentDefinition.changeDetection === constants_1.ChangeDetectionStrategy.OnPush, directiveDefs: null, pipeDefs: null, dependencies: (baseDef.standalone && componentDefinition.dependencies) || null, getStandaloneInjector: baseDef.standalone
                ? (parentInjector) => {
                    return parentInjector.get(standalone_service_1.StandaloneService).getOrCreateStandaloneInjector(def);
                }
                : null, getExternalStyles: null, signals: (_a = componentDefinition.signals) !== null && _a !== void 0 ? _a : false, data: componentDefinition.data || {}, encapsulation: componentDefinition.encapsulation || view_1.ViewEncapsulation.Emulated, styles: componentDefinition.styles || empty_1.EMPTY_ARRAY, _: null, schemas: componentDefinition.schemas || null, tView: null, id: '' });
        // TODO: Do we still need/want this ?
        if (baseDef.standalone) {
            (0, performance_1.performanceMarkFeature)('NgStandalone');
        }
        initFeatures(def);
        const dependencies = componentDefinition.dependencies;
        def.directiveDefs = extractDefListOrFactory(dependencies, /* pipeDef */ false);
        def.pipeDefs = extractDefListOrFactory(dependencies, /* pipeDef */ true);
        def.id = getComponentId(def);
        return def;
    });
}
function extractDirectiveDef(type) {
    return (0, def_getters_1.getComponentDef)(type) || (0, def_getters_1.getDirectiveDef)(type);
}
function nonNull(value) {
    return value !== null;
}
/**
 * @codeGenApi
 */
function ɵɵdefineNgModule(def) {
    return (0, closure_1.noSideEffects)(() => {
        const res = {
            type: def.type,
            bootstrap: def.bootstrap || empty_1.EMPTY_ARRAY,
            declarations: def.declarations || empty_1.EMPTY_ARRAY,
            imports: def.imports || empty_1.EMPTY_ARRAY,
            exports: def.exports || empty_1.EMPTY_ARRAY,
            transitiveCompileScopes: null,
            schemas: def.schemas || null,
            id: def.id || null,
        };
        return res;
    });
}
/**
 * Converts binding objects from the `DirectiveDefinition` into more efficient
 * lookup dictionaries that are optimized for the framework runtime.
 *
 * This function converts inputs or output directive information into new objects
 * where the public name conveniently maps to the minified internal field name.
 *
 * For inputs, the input flags are additionally persisted into the new data structure,
 * so that those can be quickly retrieved when needed.
 *
 * e.g. for
 *
 * ```ts
 * class Comp {
 *   @Input()
 *   propName1: string;
 *
 *   @Input('publicName2')
 *   declaredPropName2: number;
 *
 *   inputSignal = input(3);
 * }
 * ```
 *
 * will be serialized as
 *
 * ```ts
 * {
 *   propName1: 'propName1',
 *   declaredPropName2: ['publicName2', 'declaredPropName2'],
 *   inputSignal: [InputFlags.SignalBased, 'inputSignal'],
 * }
 * ```
 *
 * which is than translated by the minifier as:
 *
 * ```ts
 * {
 *   minifiedPropName1: 'propName1',
 *   minifiedPropName2: ['publicName2', 'declaredPropName2'],
 *   minifiedInputSignal: [InputFlags.SignalBased, 'inputSignal'],
 * }
 * ```
 *
 * becomes: (public name => minifiedName + isSignal if needed)
 *
 * ```ts
 * {
 *  'propName1': 'minifiedPropName1',
 *  'publicName2': 'minifiedPropName2',
 *  'inputSignal': ['minifiedInputSignal', InputFlags.SignalBased],
 * }
 * ```
 *
 * Optionally the function can take `declaredInputs` which will result
 * in: (public name => declared name)
 *
 * ```ts
 * {
 *  'propName1': 'propName1',
 *  'publicName2': 'declaredPropName2',
 *  'inputSignal': 'inputSignal',
 * }
 * ```
 *

 */
function parseAndConvertInputsForDefinition(obj, declaredInputs) {
    var _a;
    if (obj == null)
        return empty_1.EMPTY_OBJ;
    const newLookup = {};
    for (const minifiedKey in obj) {
        if (obj.hasOwnProperty(minifiedKey)) {
            const value = obj[minifiedKey];
            let publicName;
            let declaredName;
            let inputFlags;
            let transform;
            if (Array.isArray(value)) {
                inputFlags = value[0];
                publicName = value[1];
                declaredName = (_a = value[2]) !== null && _a !== void 0 ? _a : publicName; // declared name might not be set to save bytes.
                transform = value[3] || null;
            }
            else {
                publicName = value;
                declaredName = value;
                inputFlags = input_flags_1.InputFlags.None;
                transform = null;
            }
            newLookup[publicName] = [minifiedKey, inputFlags, transform];
            declaredInputs[publicName] = declaredName;
        }
    }
    return newLookup;
}
function parseAndConvertOutputsForDefinition(obj) {
    if (obj == null)
        return empty_1.EMPTY_OBJ;
    const newLookup = {};
    for (const minifiedKey in obj) {
        if (obj.hasOwnProperty(minifiedKey)) {
            newLookup[obj[minifiedKey]] = minifiedKey;
        }
    }
    return newLookup;
}
/**
 * Create a directive definition object.
 *
 * # Example
 * ```ts
 * class MyDirective {
 *   // Generated by Angular Template Compiler
 *   // [Symbol] syntax will not be supported by TypeScript until v2.7
 *   static ɵdir = ɵɵdefineDirective({
 *     ...
 *   });
 * }
 * ```
 *
 * @codeGenApi
 */
function ɵɵdefineDirective(directiveDefinition) {
    return (0, closure_1.noSideEffects)(() => {
        const def = getNgDirectiveDef(directiveDefinition);
        initFeatures(def);
        return def;
    });
}
/**
 * Create a pipe definition object.
 *
 * # Example
 * ```ts
 * class MyPipe implements PipeTransform {
 *   // Generated by Angular Template Compiler
 *   static ɵpipe = definePipe({
 *     ...
 *   });
 * }
 * ```
 * @param pipeDef Pipe definition generated by the compiler
 *
 * @codeGenApi
 */
function ɵɵdefinePipe(pipeDef) {
    var _a;
    return {
        type: pipeDef.type,
        name: pipeDef.name,
        factory: null,
        pure: pipeDef.pure !== false,
        standalone: (_a = pipeDef.standalone) !== null && _a !== void 0 ? _a : true,
        onDestroy: pipeDef.type.prototype.ngOnDestroy || null,
    };
}
function getNgDirectiveDef(directiveDefinition) {
    var _a;
    const declaredInputs = {};
    return {
        type: directiveDefinition.type,
        providersResolver: null,
        factory: null,
        hostBindings: directiveDefinition.hostBindings || null,
        hostVars: directiveDefinition.hostVars || 0,
        hostAttrs: directiveDefinition.hostAttrs || null,
        contentQueries: directiveDefinition.contentQueries || null,
        declaredInputs: declaredInputs,
        inputConfig: directiveDefinition.inputs || empty_1.EMPTY_OBJ,
        exportAs: directiveDefinition.exportAs || null,
        standalone: (_a = directiveDefinition.standalone) !== null && _a !== void 0 ? _a : true,
        signals: directiveDefinition.signals === true,
        selectors: directiveDefinition.selectors || empty_1.EMPTY_ARRAY,
        viewQuery: directiveDefinition.viewQuery || null,
        features: directiveDefinition.features || null,
        setInput: null,
        resolveHostDirectives: null,
        hostDirectives: null,
        inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),
        outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),
        debugInfo: null,
    };
}
function initFeatures(definition) {
    var _a;
    (_a = definition.features) === null || _a === void 0 ? void 0 : _a.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, pipeDef) {
    if (!dependencies) {
        return null;
    }
    const defExtractor = pipeDef ? def_getters_1.getPipeDef : extractDirectiveDef;
    return () => (typeof dependencies === 'function' ? dependencies() : dependencies)
        .map((dep) => defExtractor(dep))
        .filter(nonNull);
}
/**
 * A map that contains the generated component IDs and type.
 */
exports.GENERATED_COMP_IDS = new Map();
/**
 * A method can returns a component ID from the component definition using a variant of DJB2 hash
 * algorithm.
 */
function getComponentId(componentDef) {
    let hash = 0;
    // For components with i18n in templates, the `consts` array is generated by the compiler
    // as a function. If client and server bundles were produced with different minification
    // configurations, the serializable contents of the function body would be different on
    // the client and on the server. This might result in different ids generated. To avoid this
    // issue, we do not take the `consts` contents into account if it's a function.
    // See https://github.com/angular/angular/issues/58713.
    const componentDefConsts = typeof componentDef.consts === 'function' ? '' : componentDef.consts;
    // We cannot rely solely on the component selector as the same selector can be used in different
    // modules.
    //
    // `componentDef.style` is not used, due to it causing inconsistencies. Ex: when server
    // component styles has no sourcemaps and browsers do.
    //
    // Example:
    // https://github.com/angular/components/blob/d9f82c8f95309e77a6d82fd574c65871e91354c2/src/material/core/option/option.ts#L248
    // https://github.com/angular/components/blob/285f46dc2b4c5b127d356cb7c4714b221f03ce50/src/material/legacy-core/option/option.ts#L32
    const hashSelectors = [
        componentDef.selectors,
        componentDef.ngContentSelectors,
        componentDef.hostVars,
        componentDef.hostAttrs,
        componentDefConsts,
        componentDef.vars,
        componentDef.decls,
        componentDef.encapsulation,
        componentDef.standalone,
        componentDef.signals,
        componentDef.exportAs,
        JSON.stringify(componentDef.inputs),
        JSON.stringify(componentDef.outputs),
        // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
        // match in the server and browser bundles.
        Object.getOwnPropertyNames(componentDef.type.prototype),
        !!componentDef.contentQueries,
        !!componentDef.viewQuery,
    ];
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        // If client and server bundles were produced with different minification configurations,
        // the serializable contents of the function body would be different on the client and on
        // the server. Ensure that we do not accidentally use functions in component id computation.
        for (const item of hashSelectors) {
            (0, assert_1.assertNotEqual)(typeof item, 'function', 'Internal error: attempting to use a function in component id computation logic.');
        }
    }
    for (const char of hashSelectors.join('|')) {
        hash = (Math.imul(31, hash) + char.charCodeAt(0)) << 0;
    }
    // Force positive number hash.
    // 2147483647 = equivalent of Integer.MAX_VALUE.
    hash += 2147483647 + 1;
    const compId = 'c' + hash;
    if ((typeof ngDevMode === 'undefined' || ngDevMode) &&
        // Skip the check on the server since we can't guarantee the same component instance between
        // requests. Note that we can't use DI to check if we're on the server, because the component
        // hasn't been instantiated yet.
        (typeof ngServerMode === 'undefined' || !ngServerMode)) {
        if (exports.GENERATED_COMP_IDS.has(compId)) {
            const previousCompDefType = exports.GENERATED_COMP_IDS.get(compId);
            if (previousCompDefType !== componentDef.type) {
                console.warn((0, errors_1.formatRuntimeError)(-912 /* RuntimeErrorCode.COMPONENT_ID_COLLISION */, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${(0, node_selector_matcher_1.stringifyCSSSelectorList)(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
            }
        }
        else {
            exports.GENERATED_COMP_IDS.set(compId, componentDef.type);
        }
    }
    return compId;
}

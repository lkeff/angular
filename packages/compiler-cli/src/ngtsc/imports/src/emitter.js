"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnifiedModulesStrategy = exports.RelativePathStrategy = exports.LogicalProjectStrategy = exports.AbsoluteModuleStrategy = exports.LocalIdentifierStrategy = exports.ReferenceEmitter = exports.ReferenceEmitKind = exports.ImportFlags = void 0;
exports.assertSuccessfulReferenceEmit = assertSuccessfulReferenceEmit;
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
const compiler_1 = require("@angular/compiler");
const typescript_1 = __importDefault(require("typescript"));
const diagnostics_1 = require("../../diagnostics");
const file_system_1 = require("../../file_system");
const util_1 = require("../../file_system/src/util");
const typescript_2 = require("../../util/src/typescript");
const find_export_1 = require("./find_export");
/**
 * Flags which alter the imports generated by the `ReferenceEmitter`.
 */
var ImportFlags;
(function (ImportFlags) {
    ImportFlags[ImportFlags["None"] = 0] = "None";
    /**
     * Force the generation of a new import when generating a reference, even if an identifier already
     * exists in the target file which could be used instead.
     *
     * This is sometimes required if there's a risk TypeScript might remove imports during emit.
     */
    ImportFlags[ImportFlags["ForceNewImport"] = 1] = "ForceNewImport";
    /**
     * Don't make use of any aliasing information when emitting a reference.
     *
     * This is sometimes required if emitting into a context where generated references will be fed
     * into TypeScript and type-checked (such as in template type-checking).
     */
    ImportFlags[ImportFlags["NoAliasing"] = 2] = "NoAliasing";
    /**
     * Indicates that an import to a type-only declaration is allowed.
     *
     * For references that occur in type-positions, the referred declaration may be a type-only
     * declaration that is not retained during emit. Including this flag allows to emit references to
     * type-only declarations as used in e.g. template type-checking.
     */
    ImportFlags[ImportFlags["AllowTypeImports"] = 4] = "AllowTypeImports";
    /**
     * Indicates that importing from a declaration file using a relative import path is allowed.
     *
     * The generated imports should normally use module specifiers that are valid for use in
     * production code, where arbitrary relative imports into e.g. node_modules are not allowed. For
     * template type-checking code it is however acceptable to use relative imports, as such files are
     * never emitted to JS code.
     *
     * Non-declaration files have to be contained within a configured `rootDir` so using relative
     * paths may not be possible for those, hence this flag only applies when importing from a
     * declaration file.
     */
    ImportFlags[ImportFlags["AllowRelativeDtsImports"] = 8] = "AllowRelativeDtsImports";
    /**
     * Indicates that references coming from ambient imports are allowed.
     */
    ImportFlags[ImportFlags["AllowAmbientReferences"] = 16] = "AllowAmbientReferences";
})(ImportFlags || (exports.ImportFlags = ImportFlags = {}));
var ReferenceEmitKind;
(function (ReferenceEmitKind) {
    ReferenceEmitKind[ReferenceEmitKind["Success"] = 0] = "Success";
    ReferenceEmitKind[ReferenceEmitKind["Failed"] = 1] = "Failed";
})(ReferenceEmitKind || (exports.ReferenceEmitKind = ReferenceEmitKind = {}));
/**
 * Verifies that a reference was emitted successfully, or raises a `FatalDiagnosticError` otherwise.
 * @param result The emit result that should have been successful.
 * @param origin The node that is used to report the failure diagnostic.
 * @param typeKind The kind of the symbol that the reference represents, e.g. 'component' or
 *     'class'.
 */
function assertSuccessfulReferenceEmit(result, origin, typeKind) {
    if (result.kind === ReferenceEmitKind.Success) {
        return;
    }
    const message = (0, diagnostics_1.makeDiagnosticChain)(`Unable to import ${typeKind} ${(0, typescript_2.nodeNameForError)(result.ref.node)}.`, [(0, diagnostics_1.makeDiagnosticChain)(result.reason)]);
    throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.IMPORT_GENERATION_FAILURE, origin, message, [
        (0, diagnostics_1.makeRelatedInformation)(result.ref.node, `The ${typeKind} is declared here.`),
    ]);
}
/**
 * Generates `Expression`s which refer to `Reference`s in a given context.
 *
 * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
 * `Expression` which refers to a `Reference` in the context of a particular file.
 */
class ReferenceEmitter {
    constructor(strategies) {
        this.strategies = strategies;
    }
    emit(ref, context, importFlags = ImportFlags.None) {
        for (const strategy of this.strategies) {
            const emitted = strategy.emit(ref, context, importFlags);
            if (emitted !== null) {
                return emitted;
            }
        }
        return {
            kind: ReferenceEmitKind.Failed,
            ref,
            context,
            reason: `Unable to write a reference to ${(0, typescript_2.nodeNameForError)(ref.node)}.`,
        };
    }
}
exports.ReferenceEmitter = ReferenceEmitter;
/**
 * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
 * such identifiers are available.
 */
class LocalIdentifierStrategy {
    emit(ref, context, importFlags) {
        const refSf = (0, typescript_2.getSourceFile)(ref.node);
        // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
        // local identifier at all, *except* in the source file where the node is actually declared.
        if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {
            return null;
        }
        // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,
        // etc) and it is in the current file then just use it directly.
        // This is important because the reference could be a property access (e.g. `exports.foo`). In
        // such a case, the reference's `identities` property would be `[foo]`, which would result in an
        // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.
        if (!(0, typescript_2.isDeclaration)(ref.node) && refSf === context) {
            return {
                kind: ReferenceEmitKind.Success,
                expression: new compiler_1.WrappedNodeExpr(ref.node),
                importedFile: null,
            };
        }
        // If the reference is to an ambient type, it can be referenced directly.
        if (ref.isAmbient && importFlags & ImportFlags.AllowAmbientReferences) {
            const identifier = (0, typescript_2.identifierOfNode)(ref.node);
            if (identifier !== null) {
                return {
                    kind: ReferenceEmitKind.Success,
                    expression: new compiler_1.WrappedNodeExpr(identifier),
                    importedFile: null,
                };
            }
            else {
                return null;
            }
        }
        // A Reference can have multiple identities in different files, so it may already have an
        // Identifier in the requested context file.
        const identifier = ref.getIdentityIn(context);
        if (identifier !== null) {
            return {
                kind: ReferenceEmitKind.Success,
                expression: new compiler_1.WrappedNodeExpr(identifier),
                importedFile: null,
            };
        }
        else {
            return null;
        }
    }
}
exports.LocalIdentifierStrategy = LocalIdentifierStrategy;
/**
 * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
 * an absolute import.
 *
 * Part of this strategy involves looking at the target entry point and identifying the exported
 * name of the targeted declaration, as it might be different from the declared name (e.g. a
 * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
 * which maps back to the original directive, an error is thrown.
 */
class AbsoluteModuleStrategy {
    constructor(program, checker, moduleResolver, reflectionHost) {
        this.program = program;
        this.checker = checker;
        this.moduleResolver = moduleResolver;
        this.reflectionHost = reflectionHost;
        /**
         * A cache of the exports of specific modules, because resolving a module to its exports is a
         * costly operation.
         */
        this.moduleExportsCache = new Map();
    }
    emit(ref, context, importFlags) {
        if (ref.bestGuessOwningModule === null) {
            // There is no module name available for this Reference, meaning it was arrived at via a
            // relative path.
            return null;
        }
        else if (!(0, typescript_2.isDeclaration)(ref.node)) {
            // It's not possible to import something which isn't a declaration.
            throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${typescript_1.default.SyntaxKind[ref.node.kind]}.`);
        }
        else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && (0, typescript_2.isTypeDeclaration)(ref.node)) {
            throw new Error(`Importing a type-only declaration of type ${typescript_1.default.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);
        }
        // Try to find the exported name of the declaration, if one is available.
        const { specifier, resolutionContext } = ref.bestGuessOwningModule;
        const exports = this.getExportsOfModule(specifier, resolutionContext);
        if (exports.module === null) {
            return {
                kind: ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The module '${specifier}' could not be found.`,
            };
        }
        else if (exports.exportMap === null || !exports.exportMap.has(ref.node)) {
            return {
                kind: ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The symbol is not exported from ${exports.module.fileName} (module '${specifier}').`,
            };
        }
        const symbolName = exports.exportMap.get(ref.node);
        return {
            kind: ReferenceEmitKind.Success,
            expression: new compiler_1.ExternalExpr(new compiler_1.ExternalReference(specifier, symbolName)),
            importedFile: exports.module,
        };
    }
    getExportsOfModule(moduleName, fromFile) {
        if (!this.moduleExportsCache.has(moduleName)) {
            this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
        }
        return this.moduleExportsCache.get(moduleName);
    }
    enumerateExportsOfModule(specifier, fromFile) {
        // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
        const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
        if (entryPointFile === null) {
            return { module: null, exportMap: null };
        }
        const exports = this.reflectionHost.getExportsOfModule(entryPointFile);
        if (exports === null) {
            return { module: entryPointFile, exportMap: null };
        }
        const exportMap = new Map();
        for (const [name, declaration] of exports) {
            if (exportMap.has(declaration.node)) {
                // An export for this declaration has already been registered. We prefer an export that
                // has the same name as the declared name, i.e. is not an aliased export. This is relevant
                // for partial compilations where emitted references should import symbols using a stable
                // name. This is particularly relevant for declarations inside VE-generated libraries, as
                // such libraries contain private, unstable reexports of symbols.
                const existingExport = exportMap.get(declaration.node);
                if ((0, typescript_2.isNamedDeclaration)(declaration.node) && declaration.node.name.text === existingExport) {
                    continue;
                }
            }
            exportMap.set(declaration.node, name);
        }
        return { module: entryPointFile, exportMap };
    }
}
exports.AbsoluteModuleStrategy = AbsoluteModuleStrategy;
/**
 * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
 * both in the logical project "space" of paths.
 *
 * This is trickier than it sounds, as the two files may be in different root directories in the
 * project. Simply calculating a file system relative path between the two is not sufficient.
 * Instead, `LogicalProjectPath`s are used.
 */
class LogicalProjectStrategy {
    constructor(reflector, logicalFs) {
        this.reflector = reflector;
        this.logicalFs = logicalFs;
        this.relativePathStrategy = new RelativePathStrategy(this.reflector);
    }
    emit(ref, context, importFlags) {
        const destSf = (0, typescript_2.getSourceFile)(ref.node);
        // Compute the relative path from the importing file to the file being imported. This is done
        // as a logical path computation, because the two files might be in different rootDirs.
        const destPath = this.logicalFs.logicalPathOfSf(destSf);
        if (destPath === null) {
            // The imported file is not within the logical project filesystem. An import into a
            // declaration file is exempt from `TS6059: File is not under 'rootDir'` so we choose to allow
            // using a filesystem relative path as fallback, if allowed per the provided import flags.
            if (destSf.isDeclarationFile && importFlags & ImportFlags.AllowRelativeDtsImports) {
                return this.relativePathStrategy.emit(ref, context);
            }
            // Note: this error is analogous to `TS6059: File is not under 'rootDir'` that TypeScript
            // reports.
            return {
                kind: ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The file ${destSf.fileName} is outside of the configured 'rootDir'.`,
            };
        }
        const originPath = this.logicalFs.logicalPathOfSf(context);
        if (originPath === null) {
            throw new Error(`Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);
        }
        // There's no way to emit a relative reference from a file to itself.
        if (destPath === originPath) {
            return null;
        }
        const name = (0, find_export_1.findExportedNameOfNode)(ref.node, destSf, this.reflector);
        if (name === null) {
            // The target declaration isn't exported from the file it's declared in. This is an issue!
            return {
                kind: ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The symbol is not exported from ${destSf.fileName}.`,
            };
        }
        // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
        // path is now straightforward.
        const moduleName = file_system_1.LogicalProjectPath.relativePathBetween(originPath, destPath);
        return {
            kind: ReferenceEmitKind.Success,
            expression: new compiler_1.ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
exports.LogicalProjectStrategy = LogicalProjectStrategy;
/**
 * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
 *
 * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
 * necessitates the stronger logic of `LogicalProjectStrategy`.
 */
class RelativePathStrategy {
    constructor(reflector) {
        this.reflector = reflector;
    }
    emit(ref, context) {
        const destSf = (0, typescript_2.getSourceFile)(ref.node);
        const relativePath = (0, file_system_1.relative)((0, file_system_1.dirname)((0, file_system_1.absoluteFromSourceFile)(context)), (0, file_system_1.absoluteFromSourceFile)(destSf));
        const moduleName = (0, file_system_1.toRelativeImport)((0, util_1.stripExtension)(relativePath));
        const name = (0, find_export_1.findExportedNameOfNode)(ref.node, destSf, this.reflector);
        if (name === null) {
            return {
                kind: ReferenceEmitKind.Failed,
                ref,
                context,
                reason: `The symbol is not exported from ${destSf.fileName}.`,
            };
        }
        return {
            kind: ReferenceEmitKind.Success,
            expression: new compiler_1.ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
exports.RelativePathStrategy = RelativePathStrategy;
/**
 * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
 * references.
 */
class UnifiedModulesStrategy {
    constructor(reflector, unifiedModulesHost) {
        this.reflector = reflector;
        this.unifiedModulesHost = unifiedModulesHost;
    }
    emit(ref, context) {
        const destSf = (0, typescript_2.getSourceFile)(ref.node);
        const name = (0, find_export_1.findExportedNameOfNode)(ref.node, destSf, this.reflector);
        if (name === null) {
            return null;
        }
        const moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);
        return {
            kind: ReferenceEmitKind.Success,
            expression: new compiler_1.ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
exports.UnifiedModulesStrategy = UnifiedModulesStrategy;
